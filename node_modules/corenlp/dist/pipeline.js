'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _service = require('./service');

var _service2 = _interopRequireDefault(_service);

var _connectorServer = require('./connector/connector-server');

var _connectorServer2 = _interopRequireDefault(_connectorServer);

var _tokenize = require('./simple/annotator/tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _ssplit = require('./simple/annotator/ssplit');

var _ssplit2 = _interopRequireDefault(_ssplit);

var _pos = require('./simple/annotator/pos');

var _pos2 = _interopRequireDefault(_pos);

var _lemma = require('./simple/annotator/lemma');

var _lemma2 = _interopRequireDefault(_lemma);

var _ner = require('./simple/annotator/ner');

var _ner2 = _interopRequireDefault(_ner);

var _parse = require('./simple/annotator/parse');

var _parse2 = _interopRequireDefault(_parse);

var _depparse = require('./simple/annotator/depparse');

var _depparse2 = _interopRequireDefault(_depparse);

var _relation = require('./simple/annotator/relation');

var _relation2 = _interopRequireDefault(_relation);

var _regexner = require('./simple/annotator/regexner');

var _regexner2 = _interopRequireDefault(_regexner);

var _document = require('./simple/document');

var _document2 = _interopRequireDefault(_document);

var _expression = require('./simple/expression');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANNOTATORS_BY_KEY = {
  tokenize: _tokenize2.default,
  ssplit: _ssplit2.default,
  pos: _pos2.default,
  lemma: _lemma2.default,
  ner: _ner2.default,
  parse: _parse2.default,
  depparse: _depparse2.default,
  relation: _relation2.default,
  regexner: _regexner2.default
};

var LANGUAGE_TO_ISO2 = {
  English: 'en',
  French: 'fr',
  German: 'de',
  Spanish: 'es'
};

/**
 * Class representing a Pipeline.
 */

var Pipeline = function () {
  /**
   * Create a Pipeline
   * @param {Properties} properties
   * @param {string} [language] - in CamelCase (i.e. English, Spanish)
   * @param {ConnectorServer|ConnectorCli} [connector]
   */
  function Pipeline(properties) {
    var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unspecified';
    var connector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, Pipeline);

    this._properties = properties;
    this._language = language;
    this._connector = connector || new _connectorServer2.default({});
    this._service = new _service2.default(this._connector, this._language);
  }

  /**
   * Retrieves the current Service used by the pipeline
   * @param {Service} service
   */


  _createClass(Pipeline, [{
    key: 'getService',
    value: function getService() {
      return this._service;
    }

    /**
     * Execute the pipeline against the annotable object, adding annotations to it.
     * Calls the service and loads the associated response metadata into the Annotable model
     * @async
     * @param {Annotable} annotable - the document or sentence to be annotated
     * @returns {Promise.<Annotable>} annotated document / sentence
     */

  }, {
    key: 'annotate',
    value: function () {
      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(annotable) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = annotable;
                _context.next = 3;
                return this._service.getAnnotationData(annotable.text(), this._getAnnotatorsKeys(), this._getAnnotatrosOptions());

              case 3:
                _context.t1 = _context.sent;

                _context.t0.fromJson.call(_context.t0, _context.t1);

                annotable.setLanguageISO(LANGUAGE_TO_ISO2[this._language]);
                annotable.addAnnotators(this._getAnnotators());

                return _context.abrupt('return', annotable);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function annotate(_x3) {
        return _ref.apply(this, arguments);
      }

      return annotate;
    }()

    /**
     * @param {Array.<Annotator>} requiredAnnotators
     */

  }, {
    key: 'assert',
    value: function assert() {
      var methodName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var requiredAnnotators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (_lodash2.default.difference(requiredAnnotators.map(function (Annotator) {
        return new Annotator().toString();
      }), this._getAnnotatorsKeys()).length > 0) {
        throw new Error('Assert: ' + methodName + ' requires ' + requiredAnnotators.join() + ' within the annotators list.');
      }
    }

    /**
     * Annotates the given Expression instance with matching groups and/or Tokens
     * @param {Expression} expression - An annotable expression containing a TokensRegex pattern
     * @param {boolean} [annotateExpression] - Whether to hydrate the annotations with tokens or not.
     * IMPORTANT: The optional parameter `annotateExpression` if true, will run the CoreNLP pipeline
     *            twice.  First for the TokensRegex annotation, and one more for the standard pipeline
     *            Token annotations (pos, ner, lemma, etc).
     * @returns {Expression} expression - The current expression instance
     */

  }, {
    key: 'annotateTokensRegex',
    value: function () {
      var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(annotable) {
        var annotateExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.assert('TokensRegex', [_tokenize2.default, _ssplit2.default]);
                _context2.t0 = annotable;
                _context2.next = 4;
                return this._service.getTokensRegexData(annotable.text(), annotable.pattern(), this._getAnnotatorsKeys(), this._getAnnotatrosOptions());

              case 4:
                _context2.t1 = _context2.sent;

                _context2.t0.fromJson.call(_context2.t0, _context2.t1);

                annotable.setLanguageISO(LANGUAGE_TO_ISO2[this._language]);
                annotable.addAnnotator(_expression.TokensRegexAnnotator);

                if (!annotateExpression) {
                  _context2.next = 10;
                  break;
                }

                return _context2.abrupt('return', this._annotateExpression(annotable));

              case 10:
                return _context2.abrupt('return', annotable);

              case 11:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function annotateTokensRegex(_x6) {
        return _ref2.apply(this, arguments);
      }

      return annotateTokensRegex;
    }()

    /**
     * Annotates the given Expression instance with matching groups and/or Tokens
     * @param {Expression} expression - An annotable expression containing a Semgrex pattern
     * @param {boolean} [annotateExpression] - Whether to hydrate the annotations with tokens or not.
     * IMPORTANT: The optional parameter `annotateExpression` if true, will run the CoreNLP pipeline
     *            twice.  First for the Semgrex annotation, and one more for the standard pipeline
     *            Token annotations (pos, ner, lemma, etc).
     * @returns {Expression} expression - The current expression instance
     */

  }, {
    key: 'annotateSemgrex',
    value: function () {
      var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(annotable) {
        var annotateExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.assert('Semgrex', [_tokenize2.default, _ssplit2.default, _depparse2.default]);
                _context3.t0 = annotable;
                _context3.next = 4;
                return this._service.getSemgrexData(annotable.text(), annotable.pattern(), this._getAnnotatorsKeys(), this._getAnnotatrosOptions());

              case 4:
                _context3.t1 = _context3.sent;

                _context3.t0.fromJson.call(_context3.t0, _context3.t1);

                annotable.setLanguageISO(LANGUAGE_TO_ISO2[this._language]);
                annotable.addAnnotator(_expression.SemgrexAnnotator);

                if (!annotateExpression) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt('return', this._annotateExpression(annotable));

              case 10:
                return _context3.abrupt('return', annotable);

              case 11:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function annotateSemgrex(_x8) {
        return _ref3.apply(this, arguments);
      }

      return annotateSemgrex;
    }()

    /**
     * Annotates the given Expression instance with matching groups and/or Tokens
     * @param {Expression} expression - An annotable expression containing a Tregex pattern
     * @param {boolean} [annotateExpression] - Whether to hydrate the annotations with tokens or not.
     * IMPORTANT: The optional parameter `annotateExpression` if true, will run the CoreNLP pipeline
     *            twice.  First for the Tregex annotation, and one more for the standard pipeline
     *            Token annotations (pos, ner, lemma, etc).
     * @returns {Expression} expression - The current expression instance
     */

  }, {
    key: 'annotateTregex',
    value: function () {
      var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(annotable) {
        var annotateExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.assert('Tregex', [_tokenize2.default, _ssplit2.default, _parse2.default]);
                _context4.t0 = annotable;
                _context4.next = 4;
                return this._service.getTregexData(annotable.text(), annotable.pattern(), this._getAnnotatorsKeys(), this._getAnnotatrosOptions());

              case 4:
                _context4.t1 = _context4.sent;

                _context4.t0.fromJson.call(_context4.t0, _context4.t1);

                annotable.setLanguageISO(LANGUAGE_TO_ISO2[this._language]);
                annotable.addAnnotator(_expression.TregexAnnotator);

                if (!annotateExpression) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt('return', this._annotateExpression(annotable));

              case 10:
                return _context4.abrupt('return', annotable);

              case 11:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function annotateTregex(_x10) {
        return _ref4.apply(this, arguments);
      }

      return annotateTregex;
    }()

    /**
     * @description
     * Runs the default pipeline over the same text of the expression, and merges the results
     */

  }, {
    key: '_annotateExpression',
    value: function () {
      var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(annotableExpression) {
        var doc;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.annotate(new _document2.default(annotableExpression.text()));

              case 2:
                doc = _context5.sent;

                annotableExpression.mergeTokensFromDocument(doc);
                return _context5.abrupt('return', annotableExpression);

              case 5:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _annotateExpression(_x12) {
        return _ref5.apply(this, arguments);
      }

      return _annotateExpression;
    }()
  }, {
    key: '_semgrex',
    value: function () {
      var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(text, pattern) {
        var data;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._service.getSemgrexData(text, pattern, this._getAnnotatorsKeys(), this._getAnnotatrosOptions());

              case 2:
                data = _context6.sent;
                return _context6.abrupt('return', data);

              case 4:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _semgrex(_x13, _x14) {
        return _ref6.apply(this, arguments);
      }

      return _semgrex;
    }()

    /**
     * @private
     * @returns {Aray.<string>} annotators - those set for this pipeline
     */

  }, {
    key: '_getAnnotatorsKeys',
    value: function _getAnnotatorsKeys() {
      return this._properties.getProperty('annotators', '').split(',').map(function (annotatorKey) {
        return annotatorKey.trim();
      });
    }

    /**
     * @private
     * @returns {Aray.<Annotator>} annotators - those set for this pipeline
     */

  }, {
    key: '_getAnnotators',
    value: function _getAnnotators() {
      return this._getAnnotatorsKeys().map(function (annotatorKey) {
        return ANNOTATORS_BY_KEY[annotatorKey];
      });
    }

    /**
     * Only given options are those related to the annotators in the pipeline
     * @private
     * @returns {Aray.<Annotator>} annotators - those set for this pipeline
     */

  }, {
    key: '_getAnnotatrosOptions',
    value: function _getAnnotatrosOptions() {
      var pipelineProps = this._properties.getProperties();
      var validPrfixes = Object.keys(ANNOTATORS_BY_KEY);
      return Object.keys(pipelineProps).filter(function (propName) {
        return validPrfixes.indexOf(propName) === 0;
      }).reduce(function (acc, val, key) {
        return _extends({}, acc, _defineProperty({}, key, val));
      }, {});
    }
  }]);

  return Pipeline;
}();

exports.default = Pipeline;
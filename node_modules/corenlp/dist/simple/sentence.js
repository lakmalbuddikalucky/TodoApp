'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _annotable = require('./annotable');

var _annotable2 = _interopRequireDefault(_annotable);

var _tokenize = require('./annotator/tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _lemma = require('./annotator/lemma');

var _lemma2 = _interopRequireDefault(_lemma);

var _parse = require('./annotator/parse');

var _parse2 = _interopRequireDefault(_parse);

var _depparse = require('./annotator/depparse');

var _depparse2 = _interopRequireDefault(_depparse);

var _token = require('./token');

var _token2 = _interopRequireDefault(_token);

var _governor = require('./governor');

var _governor2 = _interopRequireDefault(_governor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The CoreNLP API JSON structure representing a sentence
 * @typedef SentenceJSON
 * @property {number} index
 * @property {Array.<Token>} tokens
 */

/**
 * Class representing a Sentence (@see CoreNLP.Sentence).
 * @extends Annotable
 */
var Sentence = function (_Annotable) {
  _inherits(Sentence, _Annotable);

  /**
   * Create a Sentence
   * @param {string} text
   */
  function Sentence(text) {
    _classCallCheck(this, Sentence);

    var _this = _possibleConstructorReturn(this, (Sentence.__proto__ || Object.getPrototypeOf(Sentence)).call(this, text));

    _this._tokens = [];
    _this._governors = [];
    return _this;
  }

  /**
   * Get a string representation
   * @return {string} sentence
   */


  _createClass(Sentence, [{
    key: 'toString',
    value: function toString() {
      return this._text || this._tokens.map(function (token) {
        return token.toString();
      }).join(' ');
    }

    /**
     * Get a string representation of the parse tree structure
     * @return {string} parse
     */

  }, {
    key: 'parse',
    value: function parse() {
      return this._parse;
    }

    /**
     * Get an array of string representations of the sentence words
     * @return {Array.<string>} words
     */

  }, {
    key: 'words',
    value: function words() {
      if (!this.hasAnnotator(_tokenize2.default)) {
        throw new Error('Asked for words on Sentence, but there are unmet annotator dependencies.');
      }
      return this._tokens.map(function (token) {
        return token.word();
      });
    }

    /**
     * Get a string representations of the Nth word of the sentence
     * @return {string} word
     */

  }, {
    key: 'word',
    value: function word(index) {
      if (!this.hasAnnotator(_tokenize2.default)) {
        throw new Error('Asked for a word on Sentence, but there are unmet annotator dependencies.');
      }
      return this._tokens[index].word();
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this._tokens.values();
    }

    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'posTags',
    value: function posTags() {}

    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'posTag',
    value: function posTag(index) {}
  }, {
    key: 'lemmas',
    value: function lemmas() {
      if (!this.hasAnnotator(_lemma2.default)) {
        throw new Error('Asked for lemmas on Sentence, but there are unmet annotator dependencies.');
      }
      return this._tokens.map(function (token) {
        return token.lemma();
      });
    }
  }, {
    key: 'lemma',
    value: function () {
      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(index) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt('return', this._tokens[index].lemma());

              case 1:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lemma(_x) {
        return _ref.apply(this, arguments);
      }

      return lemma;
    }()

    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'nerTags',
    value: function nerTags() {}

    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'nerTag',
    value: function nerTag(index) {}
  }, {
    key: 'governors',
    value: function governors() {
      if (!this.hasAnnotator(_depparse2.default)) {
        throw new Error('Asked for governors on Sentence, but there are unmet annotator dependencies.');
      }
      return this._governors;
    }
  }, {
    key: 'governor',
    value: function governor(index) {
      if (!this.hasAnnotator(_depparse2.default)) {
        throw new Error('Asked for a governor on Sentence, but there are unmet annotator dependencies.');
      }
      return this._governors[index];
    }

    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'incommingDependencyLabel',
    value: function incommingDependencyLabel(index) {}

    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'natlogPolarities',
    value: function natlogPolarities() {}

    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'natlogPolarity',
    value: function natlogPolarity(index) {}

    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'openie',
    value: function openie() {}

    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'openieTriples',
    value: function openieTriples(index) {}

    /**
     * Get an array of token representations of the sentence words
     * @return {Array.<Token>} tokens
     */

  }, {
    key: 'tokens',
    value: function tokens() {
      if (!this.hasAnnotator(_tokenize2.default)) {
        throw new Error('Asked for tokens on Sentence, but there are unmet annotator dependencies.');
      }
      return this._tokens;
    }

    /**
     * Get the Nth token of the sentence
     * @return {Token} token
     */

  }, {
    key: 'token',
    value: function token(index) {
      if (!this.hasAnnotator(_tokenize2.default)) {
        throw new Error('Asked for a token on Sentence, but there are unmet annotator dependencies.');
      }
      return this._tokens[index];
    }

    /**
     *
     * @returns {SentenceAlgorithms}
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'algorithms',
    value: function algorithms() {}
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        text: this._text,
        tokens: this._tokens,
        governors: this._governors,
        parse: this._parse
      };
    }

    /**
     * Update an instance of Sentence with data provided by a JSON
     * @param {SentenceJSON} data - The document data, as returned by CoreNLP API service
     * @param {boolean} [isSentence] - Indicate if the given data represents just the sentence
     * of a full document
     * @returns {Sentence} document - The current document instance
     */

  }, {
    key: 'fromJson',
    value: function fromJson(data) {
      var _this2 = this;

      var isSentence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var sentence = isSentence ? data : _lodash2.default.head(data.sentences);
      if (sentence.tokens) {
        this.addAnnotator(_tokenize2.default);
        this._tokens = sentence.tokens.map(function (tok) {
          return _token2.default.fromJson(tok);
        });
      }
      if (sentence.parse) {
        this.addAnnotator(_parse2.default);
        this._parse = sentence.parse;
      }
      if (sentence.basicDependencies) {
        this.addAnnotator(_depparse2.default);
        this._governors = sentence.basicDependencies.map(function (gov) {
          return new _governor2.default(gov.dep, _this2._tokens[gov.governor - 1], _this2._tokens[gov.dependent - 1]);
        });
        // @see relation annotator...
        this._basicDependencies = sentence.basicDependencies;
        this._enhancedDependencies = sentence.enhancedDependencies;
        this._enhancedPlusPlusDependencies = sentence.enhancedPlusPlusDependencies;
      }
      return this;
    }

    /**
     * Get an instance of Sentence from a given JSON
     * @param {SentenceJSON} data - The document data, as returned by CoreNLP API service
     * @param {boolean} [isSentence] - Indicate if the given data represents just the sentence of a
     * full document
     * @returns {Sentence} document - A new Sentence instance
     */

  }], [{
    key: 'fromJson',
    value: function fromJson(data) {
      var isSentence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var instance = new this();
      return instance.fromJson(data, isSentence);
    }
  }]);

  return Sentence;
}(_annotable2.default);

exports.default = Sentence;
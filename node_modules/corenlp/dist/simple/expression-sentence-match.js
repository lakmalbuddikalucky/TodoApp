"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @typedef ExpressionSentenceMatchGroup
 * @property {string} label - group label
 * @property {number} begin - 0-based index of the matched group, relative to the given text
 * @property {number} end - 0-based index of the matched group, relative to the given text
 * @property {Token} [token] - onluy given if aggregated with an annotated Sentence or Document
 * @property {ExpressionSentenceMatchGroup} $[label] - other groups inside
 */

/**
 * A ExpressionSentenceMatch of either `TokensRegex`, `Semrgex` or `Tregex`.
 * @typedef ExpressionSentenceMatchJSON
 * @property {number} begin - word begin position, starting from zero
 * @property {number} end - word end position, starting from zero (no match ends at 0)
 * @property {string} text - matched text
 * @property {string} $[label] - any label, as defined in the expression pattern
 */
var ExpressionSentenceMatch = function () {
  function ExpressionSentenceMatch() {
    _classCallCheck(this, ExpressionSentenceMatch);
  }

  _createClass(ExpressionSentenceMatch, [{
    key: "groups",

    /**
     * Returns the main and labeled groups as a list of ExpressionSentenceMatchGroup
     * @returns {Array.<ExpressionSentenceMatchGroup>} groups
     */
    value: function groups() {
      var _this = this;

      return [this._data].concat(this.labels().map(function (label) {
        return _this.group(label);
      }));
    }

    /**
     * Returns the labeled group as ExpressionSentenceMatchGroup from a given label
     * @description
     * Nodes in a Macthed expression can be named, we call them groups here, and
     * the labels are the name of the nodes.
     * @see {@link https://nlp.stanford.edu/nlp/javadoc/javanlp/edu/stanford/nlp/semgraph/semgrex/SemgrexPattern.html#Naming_nodes}
     * @param {string} label - The label name, not prefixed wih $
     * @returns {ExpressionSentenceMatchGroup} group
     */

  }, {
    key: "group",
    value: function group(label) {
      return this._data["$" + label];
    }

    /**
     * Retrieves the list of labels (aliases) available for the current sentence match.
     * @description
     * Labels are those aliases you can add to a group match expression, for example,
     * in Semgrex, you can do {ner:/PERSON/=good_guy}, from where "good_guy" would be the label
     * and internally it will come as $good_guy as a member of {@link ExpressionSentenceMatchGroup}.
     * @returns {Array.<string>} labels
     */

  }, {
    key: "labels",
    value: function labels() {
      return Object.keys(this._data).filter(function (key) {
        return (/^\$/.test(key)
        );
      }).map(function (label) {
        return label.substr(1);
      });
    }

    /**
     * Update an instance of ExpressionSentenceMatch with data provided by a JSON
     * @param {ExpressionSentenceMatchJSON} data - The match data, as returned by CoreNLP API service
     * @returns {ExpressionSentenceMatch} expression - The current match instance
     */

  }, {
    key: "fromJson",
    value: function fromJson(data) {
      this._data = data;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _extends({}, this._data);
    }

    /**
     * Get an instance of ExpressionSentenceMatch from a given JSON
     * @param {ExpressionSentenceMatchJSON} data - The match data, as returned by CoreNLP API service
     * @returns {ExpressionSentenceMatch} match - A new ExpressionSentenceMatch instance
     */

  }], [{
    key: "fromJson",
    value: function fromJson(data) {
      var instance = new this();
      return instance.fromJson(data);
    }
  }]);

  return ExpressionSentenceMatch;
}();

exports.default = ExpressionSentenceMatch;
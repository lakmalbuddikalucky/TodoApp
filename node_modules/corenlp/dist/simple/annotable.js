"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class representing an Annotable.
 */
var Annotable = function () {
  /**
   * Create an Annotable
   * @param {string} text
   */
  function Annotable(text) {
    _classCallCheck(this, Annotable);

    this._text = text;
    this._annotators = {};
  }

  /**
   * Get a string representation of the raw text
   * @return {string} text
   */


  _createClass(Annotable, [{
    key: "text",
    value: function text() {
      return this._text;
    }

    /**
     * Sets the language ISO (given by the pipeline during the annotation process)
     * This is solely to keep track of the language chosen for further analysis
     * @return {string} text
     */

  }, {
    key: "setLanguageISO",
    value: function setLanguageISO(iso) {
      this._language = iso;
    }

    /**
     * Retrieves the language ISO
     * @return {string} text
     */

  }, {
    key: "getLanguageISO",
    value: function getLanguageISO() {
      return this._language;
    }

    /**
     * Marks an annotator as a met dependency
     * @param {Annotator|function} annotator
     */

  }, {
    key: "addAnnotator",
    value: function addAnnotator(annotator) {
      this._annotators[annotator.toString()] = annotator;
    }

    /**
     * Marks multiple annotators as a met dependencies
     * @param {Array.<Annotator|function>} annotators
     */

  }, {
    key: "addAnnotators",
    value: function addAnnotators(annotators) {
      var _this = this;

      annotators.forEach(function (annotator) {
        return _this.addAnnotator(annotator);
      });
    }

    /**
     * Unmarks an annotator as a met dependency
     * @param {Annotator|function} annotator
     */

  }, {
    key: "removeAnnotator",
    value: function removeAnnotator(annotator) {
      delete this._annotators[annotator.toString()];
    }

    /**
     * Tells you if an annotator is a met dependency
     * @param {Annotator|function} annotator
     * @returns {boolean} hasAnnotator
     */

  }, {
    key: "hasAnnotator",
    value: function hasAnnotator(annotator) {
      return !!this._annotators[annotator.toString()];
    }

    /**
     * Tells you if at least on of a list of annotators is a met dependency
     * @param {Array.<Annotator|function>} annotators
     * @returns {boolean} hasAnyAnnotator
     */

  }, {
    key: "hasAnyAnnotator",
    value: function hasAnyAnnotator(annotators) {
      var _this2 = this;

      return annotators.some(function (annotator) {
        return (
          // eslint-disable-next-line no-bitwise
          !!~Object.keys(_this2._annotators).indexOf(annotator.toString())
        );
      });
    }
  }]);

  return Annotable;
}();

exports.default = Annotable;
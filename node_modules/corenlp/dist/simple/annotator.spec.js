'use strict';

var _annotator = require('./annotator');

var _annotator2 = _interopRequireDefault(_annotator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Annotator', function () {
  var annotator = void 0;

  beforeEach(function () {
    annotator = new _annotator2.default('tokenize', {
      whitespace: true,
      keepeol: false,
      verbose: true
    });
  });

  context('Pipeline setup', function () {
    describe('options / option', function () {
      it('should return the given options', function () {
        expect(annotator.options()).to.deep.equal({
          whitespace: true,
          keepeol: false,
          verbose: true
        });
      });

      it('should return the given option', function () {
        expect(annotator.option('whitespace')).to.be.true;
        expect(annotator.option('keepeol')).to.be.false;
        expect(annotator.option('verbose')).to.be.true;
      });

      it('should set the given option', function () {
        expect(annotator.option('keepeol')).to.be.false;
        expect(annotator.option('keepeol', 'testset')).to.equal('testset');
        expect(annotator.option('keepeol')).to.equal('testset');
      });
    });

    describe('dependencies', function () {
      it('should return the given dependencies', function () {
        var dep1 = new _annotator2.default('testdep', { testopt: true, testopt2: 'test' });
        var dep2 = new _annotator2.default('testdep2', { testopt: true, testopt2: 'test' });
        annotator = new _annotator2.default('tokenize', { whitespace: true, keepeol: false, verbose: true }, [dep1, dep2]);
        expect(annotator.dependencies()).to.deep.equal([dep1, dep2]);
      });
    });

    describe('pipeline', function () {
      it('should return the given dependencies', function () {
        annotator = new _annotator2.default('tokenize', { whitespace: true, keepeol: false, verbose: true }, [new _annotator2.default('testdep', { testopt: true, testopt2: 'test' }), new _annotator2.default('testdep2', { testopt: true, testopt2: 'test' }, [new _annotator2.default('testdep3', { testopt: true, testopt2: 'test' }, [new _annotator2.default('testdep4', { testopt: true, testopt2: 'test' })])])]);
        expect(annotator.pipeline()).to.deep.equals(['testdep', 'testdep4', 'testdep3', 'testdep2', 'tokenize']);
      });
    });

    describe('pipelineOptions', function () {
      it('should return the options of the current annotator', function () {
        expect(annotator.pipelineOptions()).to.deep.equal({
          'tokenize.whitespace': true,
          'tokenize.keepeol': false,
          'tokenize.verbose': true
        });
      });

      it('should return the options of the current annotator and its dependencies', function () {
        annotator = new _annotator2.default('tokenize', { whitespace: true, keepeol: false, verbose: true }, [new _annotator2.default('testdep', { testopt: true, testopt2: 'test' }), new _annotator2.default('testdep2', { testopt: true, testopt2: 'test' })]);

        expect(annotator.pipelineOptions()).to.deep.equal({
          'testdep.testopt': true,
          'testdep.testopt2': 'test',
          'testdep2.testopt': true,
          'testdep2.testopt2': 'test',
          'tokenize.whitespace': true,
          'tokenize.keepeol': false,
          'tokenize.verbose': true
        });
      });

      it('should return the options of the current annotator and its dependencies\' dependencies', function () {
        annotator = new _annotator2.default('tokenize', { whitespace: true, keepeol: false, verbose: true }, [new _annotator2.default('testdep', { testopt: true, testopt2: 'test' }), new _annotator2.default('testdep2', { testopt: true, testopt2: 'test' }, [new _annotator2.default('testdep3', { testopt: true, testopt2: 'test' }, [new _annotator2.default('testdep4', { testopt: true, testopt2: 'test' })])])]);

        expect(annotator.pipelineOptions()).to.deep.equal({
          'testdep.testopt': true,
          'testdep.testopt2': 'test',
          'testdep2.testopt': true,
          'testdep2.testopt2': 'test',
          'testdep3.testopt': true,
          'testdep3.testopt2': 'test',
          'testdep4.testopt': true,
          'testdep4.testopt2': 'test',
          'tokenize.whitespace': true,
          'tokenize.keepeol': false,
          'tokenize.verbose': true
        });
      });
    });
  });

  context('Other methods', function () {
    describe('toString', function () {
      it('should return the given name', function () {
        expect(annotator.toString()).to.equals('tokenize');
      });
    });

    describe('equalsTo', function () {
      it('should accept annotators with same name', function () {
        var annotatorMock = {
          toString: sinon.stub().returns('tokenize')
        };
        expect(annotator.equalsTo(annotatorMock)).to.be.true;
        expect(annotatorMock.toString).to.be.calledOnce;
      });

      it('should accept annotators with same name but different options', function () {
        var annotator1 = new _annotator2.default('tokenize', { language: 'English' });
        var annotator2 = new _annotator2.default('tokenize', { language: 'Unspecified' });
        expect(annotator1.equalsTo(annotator2)).to.be.true;
      });

      it('should reject annotators with different name', function () {
        var annotatorMock = {
          toString: sinon.stub().returns('ner')
        };
        expect(annotator.equalsTo(annotatorMock)).to.be.false;
        expect(annotatorMock.toString).to.be.calledOnce;
      });
    });
  });
});
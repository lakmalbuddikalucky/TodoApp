'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _annotable = require('./annotable');

var _annotable2 = _interopRequireDefault(_annotable);

var _ssplit = require('./annotator/ssplit');

var _ssplit2 = _interopRequireDefault(_ssplit);

var _sentence = require('./sentence');

var _sentence2 = _interopRequireDefault(_sentence);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The CoreNLP API JSON structure representing a document
 * @typedef DocumentJSON
 * @property {number} index
 * @property {Array.<Sentence>} sentences
 */

/**
 * Class representing a Document (@see CoreNLP.Document).
 * @extends Annotable
 */
var Document = function (_Annotable) {
  _inherits(Document, _Annotable);

  /**
   * Create a Document
   * @param {string} text
   */
  function Document(text) {
    _classCallCheck(this, Document);

    var _this = _possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).call(this, text));

    _this._sentences = [];
    return _this;
  }

  /**
   * Get a string representation
   * @return {string} document
   */


  _createClass(Document, [{
    key: 'toString',
    value: function toString() {
      return this._text || this._sentences.map(function (sent) {
        return sent.toString();
      }).join('. ');
    }

    /**
     * Get a list of sentences
     * @returns {Array.<Sentence>} sentences - The document sentences
     */

  }, {
    key: 'sentences',
    value: function sentences() {
      if (!this.hasAnnotator(_ssplit2.default)) {
        throw new Error('Asked for sentences on Document, but there are unmet annotator dependencies.');
      }
      return this._sentences;
    }

    /**
     * Get the sentence for a given index
     * @param {number} index - The position of the sentence to get
     * @returns {Sentence} sentence - The document sentences
     */

  }, {
    key: 'sentence',
    value: function sentence(index) {
      return this.sentences()[index];
    }

    /**
     * TODO
     * requirements: tokenize, ssplit, pos, lemma, ner, parse
     * https://stanfordnlp.github.io/CoreNLP/dcoref.html
     * @returns {Promise.<DeterministicCorefAnnotator>} dcoref 
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'coref',
    value: function coref() {}

    /**
     * Update an instance of Document with data provided by a JSON
     * @param {DocumentJSON} data - The document data, as returned by CoreNLP API service
     * @returns {Document} document - The current document instance
     */

  }, {
    key: 'fromJson',
    value: function fromJson(data) {
      if (data.sentences) {
        this.addAnnotator(_ssplit2.default);
        this._sentences = data.sentences.map(function (sent) {
          return _sentence2.default.fromJson(sent, true);
        });
      }
      return this;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        text: this._text,
        sentences: this._sentences
      };
    }

    /**
     * Get an instance of Document from a given JSON
     * @param {DocumentJSON} data - The document data, as returned by CoreNLP API service
     * @returns {Document} document - A new Document instance
     */

  }], [{
    key: 'fromJson',
    value: function fromJson(data) {
      var instance = new this();
      return instance.fromJson(data);
    }
  }]);

  return Document;
}(_annotable2.default);

exports.default = Document;
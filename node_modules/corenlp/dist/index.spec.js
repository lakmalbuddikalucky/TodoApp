'use strict';

var _ = require('.');

var _2 = _interopRequireDefault(_);

var _document = require('./simple/document');

var _document2 = _interopRequireDefault(_document);

var _sentence = require('./simple/sentence');

var _sentence2 = _interopRequireDefault(_sentence);

var _token = require('./simple/token');

var _token2 = _interopRequireDefault(_token);

var _annotable = require('./simple/annotable');

var _annotable2 = _interopRequireDefault(_annotable);

var _annotator = require('./simple/annotator');

var _annotator2 = _interopRequireDefault(_annotator);

var _tokenize = require('./simple/annotator/tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _ssplit = require('./simple/annotator/ssplit');

var _ssplit2 = _interopRequireDefault(_ssplit);

var _pos = require('./simple/annotator/pos');

var _pos2 = _interopRequireDefault(_pos);

var _lemma = require('./simple/annotator/lemma');

var _lemma2 = _interopRequireDefault(_lemma);

var _ner = require('./simple/annotator/ner');

var _ner2 = _interopRequireDefault(_ner);

var _parse = require('./simple/annotator/parse');

var _parse2 = _interopRequireDefault(_parse);

var _depparse = require('./simple/annotator/depparse');

var _depparse2 = _interopRequireDefault(_depparse);

var _relation = require('./simple/annotator/relation');

var _relation2 = _interopRequireDefault(_relation);

var _regexner = require('./simple/annotator/regexner');

var _regexner2 = _interopRequireDefault(_regexner);

var _tree = require('./util/tree');

var _tree2 = _interopRequireDefault(_tree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

describe('CoreNLP Library entry point', function () {
  describe('CoreNLP', function () {
    describe('constructor', function () {
      it('should have a constructor method', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                expect(_2.default).to.have.property('constructor').that.is.a('function');

              case 1:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, undefined);
      })));
    });

    describe('connector', function () {
      it('should have ConnectorServer', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                expect(_.ConnectorServer).to.be.a('function');

              case 1:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, undefined);
      })));

      it('should have ConnectorCli', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                expect(_.ConnectorCli).to.be.a('function');

              case 1:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, undefined);
      })));
    });

    describe('simple', function () {
      it('should have Annotable', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                expect(_2.default.simple).to.have.property('Annotable').that.equals(_annotable2.default);

              case 1:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, undefined);
      })));

      it('should have Annotator', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                expect(_2.default.simple).to.have.property('Annotator').that.equals(_annotator2.default);

              case 1:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, undefined);
      })));

      it('should have Document', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                expect(_2.default.simple).to.have.property('Document').that.equals(_document2.default);

              case 1:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, undefined);
      })));

      it('should have Sentence', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                expect(_2.default.simple).to.have.property('Sentence').that.equals(_sentence2.default);

              case 1:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, undefined);
      })));

      it('should have Token', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                expect(_2.default.simple).to.have.property('Token').that.equals(_token2.default);

              case 1:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, undefined);
      })));

      describe('annotator', function () {
        it('should have annotators', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {
          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  expect(_2.default.simple).to.have.property('annotator').that.deep.equals({
                    TokenizerAnnotator: _tokenize2.default,
                    WordsToSentenceAnnotator: _ssplit2.default,
                    POSTaggerAnnotator: _pos2.default,
                    MorphaAnnotator: _lemma2.default,
                    NERClassifierCombiner: _ner2.default,
                    ParserAnnotator: _parse2.default,
                    DependencyParseAnnotator: _depparse2.default,
                    RelationExtractorAnnotator: _relation2.default,
                    RegexNERAnnotator: _regexner2.default
                  });

                case 1:
                case 'end':
                  return _context9.stop();
              }
            }
          }, _callee9, undefined);
        })));
      });
    });

    describe('util', function () {
      it('should have Tree', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                expect(_2.default.util).to.have.property('Tree').that.equals(_tree2.default);

              case 1:
              case 'end':
                return _context10.stop();
            }
          }
        }, _callee10, undefined);
      })));
    });

    describe('Integration Test', function () {
      context('Using ConnectorServer', _asyncToGenerator(regeneratorRuntime.mark(function _callee12() {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                it('should allow to initialize a pipeline and run annotations', _asyncToGenerator(regeneratorRuntime.mark(function _callee11() {
                  var connector, props, pipeline, sent;
                  return regeneratorRuntime.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          connector = new _.ConnectorServer({ dsn: 'http://localhost:9000' });

                          sinon.stub(connector, 'get').returns(Promise.resolve({
                            sentences: [{
                              tokens: [{
                                word: 'Hello',
                                pos: 'UH',
                                ner: 'O'
                              }, {
                                word: 'world',
                                pos: 'NN',
                                ner: 'O'
                              }]
                            }]
                          }));
                          props = new _.Properties({
                            annotators: 'tokenize,ssplit'
                          });
                          pipeline = new _.Pipeline(props, 'English', connector);
                          sent = new _2.default.simple.Sentence('Hello world');
                          _context11.next = 7;
                          return pipeline.annotate(sent);

                        case 7:
                          expect(sent.word(0)).to.equal('Hello');
                          expect(sent.word(1)).to.equal('world');
                          expect(sent.token(0).pos()).to.equal('UH');
                          expect(sent.token(1).pos()).to.equal('NN');
                          expect(sent.token(0).ner()).to.equal('O');
                          expect(sent.token(1).ner()).to.equal('O');

                        case 13:
                        case 'end':
                          return _context11.stop();
                      }
                    }
                  }, _callee11, undefined);
                })));

              case 1:
              case 'end':
                return _context12.stop();
            }
          }
        }, _callee12, undefined);
      })));

      context('Using ConnectorCli', _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                it('should allow to initialize a pipeline and run annotations', _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {
                  var connector, props, pipeline, sent;
                  return regeneratorRuntime.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          connector = new _.ConnectorCli({
                            classPath: 'corenlp/stanford-corenlp-full-2017-06-09/*',
                            mainClass: 'edu.stanford.nlp.pipeline.StanfordCoreNLP',
                            props: 'StanfordCoreNLP-spanish.properties'
                          });

                          sinon.stub(connector, 'get').returns(Promise.resolve({
                            sentences: [{
                              tokens: [{
                                word: 'Hello',
                                pos: 'UH',
                                ner: 'O'
                              }, {
                                word: 'world',
                                pos: 'NN',
                                ner: 'O'
                              }]
                            }]
                          }));
                          props = new _.Properties({
                            annotators: 'tokenize,ssplit'
                          });
                          pipeline = new _.Pipeline(props, 'English', connector);
                          sent = new _2.default.simple.Sentence('Hello world');
                          _context13.next = 7;
                          return pipeline.annotate(sent);

                        case 7:
                          expect(sent.word(0)).to.equal('Hello');
                          expect(sent.word(1)).to.equal('world');
                          expect(sent.token(0).pos()).to.equal('UH');
                          expect(sent.token(1).pos()).to.equal('NN');
                          expect(sent.token(0).ner()).to.equal('O');
                          expect(sent.token(1).ner()).to.equal('O');

                        case 13:
                        case 'end':
                          return _context13.stop();
                      }
                    }
                  }, _callee13, undefined);
                })));

              case 1:
              case 'end':
                return _context14.stop();
            }
          }
        }, _callee14, undefined);
      })));
    });
  });
});